---
title: "Zeman's lab single cell RNA-Seq analysis report (combined expt 1 and 2)"
author: "Kent Riemondy RBI"
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    fig_caption: yes
    fig_retina: 1 
    code_folding: hide
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(cache.lazy = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```



```{r libs, message=FALSE, warning=FALSE, echo=FALSE}
library(Seurat)
library(readr)
library(tidyr)
library(plyr)
library(dplyr)
library(stringr)
library(ggplot2)
library(cowplot)
library(RColorBrewer)
library(Matrix)
library(purrr)
library(ComplexHeatmap)
library(org.Mm.eg.db)
```


## Experiment Summary
  In the lung alveolar walls there are three major types of cells. Type I cells are thin cells that allow gas exchange to capillaries. Type II cells are granular cells that release surfacant substances to promote a low surface tension environment. Lastly, macrophages are also present and phagocytose foreign materials.  
  
  The Type I cells are terminally differentiated, and are unable to replicate in response to damaging insults. Type II cells proliferate and transdifferentiate into Type I cells to restore Type I cell populations following injury. However, the molecular mechanisms regulating the transdifferentiation process *in vivo* remain inadequately characterized. 
  
  Single cell RNA-Seq was performed on ATI and ATII cell populations isolated from control or injured mice. The goal of this experiment is gain unique insight into transcriptomes of cells undergoing transdifferentiation, hopefully uncovering novel markers for further characterization, and potential regulatory factor to further investigate.  
  
  The single cell experiment was performed twice. The repeat experiment had a similar design, except that many more injured type II cells were capured. 
  
  
Experment | Sample | Description
------------- | ---------------- | --------------------
2017-06-23 | 3161-ATII-1 | Control Mouse, Type I Alveolar cells, rep. 1
2017-06-23 | 3161-ATII-2 | Control Mouse, Type I Alveolar cells, rep. 2
2017-06-23 | 3161-ATII-3 | Control Mouse, Type II Alveolar cells
2017-06-23 | 3162-ATIII-5 | Injured Mouse (LPS), Type II Alveolar cells, rep. 2
2017-06-23 | 3162-ATII-4 | Injured Mouse (LPS), Type II Alveolar cells, rep 1
2017-07-28 | 3242ATI1 | Control Mouse, Type I Alveolar cells, rep. 1
2017-07-28 | 3242ATI2  | Control Mouse, Type I Alveolar cells, rep. 2
2017-07-28 | 3242ATII3  | Control Mouse, Type II Alveolar cells
2017-07-28 | 3241ATII4 | Injured Mouse (LPS), Type II Alveolar cells, rep. 1 
2017-07-28 | 3241ATII5 | Injured Mouse (LPS), Type II Alveolar cells, rep 2


```{r Zemans_data, eval = T}
atcells <- readRDS("analyzed_seurat_object_all.rds")
atcells_cluster_markers <- suppressMessages(read_tsv("res0.8_markers.txt"))
atcells_merged_markers <- suppressMessages(read_tsv("res0.8_merged_markers.txt"))
summary_dat <- suppressMessages(read_tsv("per_cell_stats.txt",
                        col_types = c("cddcccdccddd")))

# make sure identity is set to original
atcells <- SetAllIdent(atcells, "orig.ident")
```

## QC Metrics
  
```{r examine_umi_and_ngenes, fig.width = 10, fig.height = 8, warning = F, cache=T}
summary_dat <- read_tsv("per_cell_stats.txt",
                        col_types = c("cddcccdccddd"))
n_cells <- summary_dat %>%  
  group_by(sample) %>%  
  summarize(n_cells = n(),
            median_UMIs = median(nUMIs),
            median_Genes = median(nGenes))

knitr::kable(n_cells,
             caption = "Number of cells prior to filtering and summary statistics")

a <- ggplot(summary_dat, aes(sample, nUMIs)) +
  geom_violin(aes(fill = sample)) +
  scale_fill_brewer(palette = "Paired") +
  ylab("Number of UMIs") +
  theme(axis.text.x = element_blank())

b <- ggplot(summary_dat, aes(sample, nGenes)) +
    geom_violin(aes(fill = sample)) +
  scale_fill_brewer(palette = "Paired") +
  ylab("Number of Genes (at least 1 UMI)") +
  theme(axis.text.x = element_blank())
plot_grid(a, b, ncol = 1)
```

Overall the numbers of UMIs and genes detected are good and in the expected range for single cell data. 

## Mitochondrial Reads {.tabset .tabset-fade}
The percentage of reads aligning to mitochondria is often an indicator of cell quality. Cells that have lysed prior to capture preferentially retain mitochondial RNA, but lose cellular cytoplasmic mRNA. As shown below there is a strong negative correlation with the number of UMIs and the proportion of reads aligning to mitochondria. Cells with less than 20% mitochondrial reads will be retained for further analysis.

```{r QC, fig.width = 10}

ggplot(summary_dat, aes(sample_names,
                       proportion.mito)) +
  geom_violin(aes(fill = sample_names)) +
  geom_jitter(size = 0.25) +
  scale_fill_brewer(palette = "Paired")

```

### All Samples

```{r}
ggplot(summary_dat, aes(nUMI, proportion.mito)) +
        geom_point(aes(color = sample_names)) +
  scale_color_brewer(palette = "Paired")
```

```{r, results ='asis'}

sample_names <- as.character(unique(atcells@data.info$orig.ident))
per_sample <- map(sample_names, ~filter(summary_dat, 
                                        sample_names == .x))

# generate tab with individual plot programmatically 
# see https://stackoverflow.com/questions/43752095/programmatically-insert-header-and-plot-in-same-code-chunk-with-r-markdown-using?noredirect=1&lq=1

for(i in seq_along(per_sample)){
  .col <- brewer.pal(10, "Paired")[i]
  cat('\n### ', sample_names[i], '\n')
  p <- ggplot(per_sample[[i]], aes(nUMI, proportion.mito)) +
        geom_point(aes(color = sample_names)) +
        scale_color_manual(values = .col)
  print(p)
  cat('\n')
}
```

Cells with low UMIs tend to have a higher percentage of mitochondrial reads, suggesting that these cells have lysed prematurely. However, overall a large proportion of cells are retained for further analysis after removing cells with > 20% UMIs derived from mitochondiral transcripts. 

## Filtered Data {.tabset .tabset-fade}

After filtering the distribution of UMIs, Genes, Proportion of mitochondrial reads, and number GFP reads are shown as selectable tabs. 

```{r ngenes_filter}
cell_counts <- function(seurat_object){
  #returns tbl_df with number of cells per sample type in seurat object
  map_df(levels(seurat_object@ident), 
         ~data_frame(sample = .x, 
                     n_cells = length(WhichCells(seurat_object, ident = .x))))
}

knitr::kable(cell_counts(atcells),
             caption = "Number of cells passing an additional filter requiring less than 20% mitochondrial reads and at least 250 genes detected, and UMI < 40000")
```




### Number of Genes
```{r ngenes_post_filter}
VlnPlot(atcells, "nGene", 
        cols.use = brewer.pal(10, "Paired"),
        group.by = "sample_names")
```

### Number of UMIs
```{r}
VlnPlot(atcells, "nUMI", 
        cols.use = brewer.pal(10, "Paired"),
        group.by = "sample_names")
```

### Proportion of Mitochondria
```{r}
VlnPlot(atcells, "proportion.mito", 
        cols.use = brewer.pal(10, "Paired"),
        group.by = "sample_names")

```

### GFP counts

```{r read_in_counts, message = F}
VlnPlot(atcells, 
        "gfp_counts",
        cols.use = brewer.pal(n = 10, "Paired"), 
        group.by = "sample_names")
```

The number of reads mapping to GFP is consistent with the sorting strategy utilized to isolate the cells. Very low numbers of reads map to GFP in the ATI population, in constrast to the ATII population which is GFP+. 

## PCA Projection {.tabset}
  To get an overview of the relationships between the different cell types, PCA was used. Shown below is a plot of the first two principal components computed using highly variable genes (`r length(atcells@var.genes)` genes). Highly variable genes are most informative for PCA/clustering as these genes tend to be the genes that define different cell populations. 
  
  Shown in the tabs are 2 dimensional plots showing different principal components. Overall the data looks good as there is quite alot of structure to the data and many consisent populations observed.

```{r, results ='asis'}
pcs <- list(
  c(1, 2),
  c(1, 3),
  c(1, 4),
  c(2, 3),
  c(2, 4),
  c(3, 4)
)


for(i in seq_along(pcs)){
  cat('\n### ', 'PC', pcs[[i]][1], ' vs PC', pcs[[i]][2], '\n', sep = "")
  PCAPlot(atcells, 
               pcs[[i]][1], 
               pcs[[i]][2], 
               cols.use = brewer.pal(10, "Paired"), 
        group.by = "sample_names")
  #print(p)
  cat('\n')
}
```


## TSNE projection {.tabset .tabset-fade}
  PCA analysis is useful for identifying the most variable dimensions in the dataset. However in single cell datasets there are often many dimensions that are informative for clustering the cells. [TSNE](https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding) is a non-linear dimensionality reduction algorithm that is particularly well-suited for projecting multidimensional data in two dimensional space. 
  
  Shown below is a TSNE projection of the single cell data, with each cell colored by the sample type. Additional variables are also plotted as separate tabs, including coloring the cells by experiment, # of reads of GFP, proportion of mitochondria, number of UMIS, and number of gene detected. 
  
  The TSNE project shows a very consistent pattern between the replicate experiments. The clusters all overlap very nicely, with a few exceptions. In the injured type II samples there are some distinct clusters. However overall the two experiments overlap very well. There are additional normalization approaches that I will implement (using [this](http://www.biorxiv.org/content/early/2017/07/18/164889) method) to further clean up the data to help align the two experiments, but this may not be necessary as the overlap is already quite good.  
  
### By Sample
```{r plot_TSNE, fig.width = 10, fig.height = 10}
TSNEPlot(atcells, 
         colors.use = brewer.pal(n = 10, "Paired"), 
         group.by = "sample_names")

```

### Experiment
```{r, fig.width = 10, fig.height = 10 }
TSNEPlot(atcells, 
         colors.use = brewer.pal(n = 10, "Paired"), 
         group.by = "expt")
```

### GFP
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(atcells,"gfp_counts", no.legend = F)
```

### Genes Detected
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(atcells, "nGene", no.legend = F)
```

### UMIs Detected
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(atcells, "nUMI", no.legend = F)
```

### Proportion Mito
```{r, fig.width = 10, fig.height = 10 }
FeaturePlot(atcells, "proportion.mito", no.legend = F)
```



```{r allsamples, fig.width = 16, fig.height= 10 , eval = F}

ord <- levels(atcells@data.info$orig.ident)
ord <- ord[c(1:5, 8, 9, 6, 7, 10)]

cell_ids <- map(ord, ~atcells@cell.names[atcells@data.info$orig.ident == .x])
names(cell_ids) <- sample_names
.cols <- brewer.pal(n = 10, "Paired")
cols_to_pick <- list(c(1:9),
                     c(2:7, 10:11),
                     -7)
p <- map(cell_ids,
         ~TSNEPlot(atcells, 
                   do.label = T, 
                   pt.size = 0.5, 
                   cells.use = .x, 
                   do.return = T, 
                   label.size = 5))

p[[11]] <- TSNEPlot(atcells, 
         colors.use = brewer.pal(n = 10, "Paired"), 
         group.by = "sample_names", 
         cells.use = unlist(cell_ids[1:5]),
         do.return = T, label.size = 5, pt.size = 0.5)

p[[12]] <- TSNEPlot(atcells, 
         colors.use = brewer.pal(n = 10, "Paired"), 
         group.by = "sample_names", 
         cells.use = unlist(cell_ids[6:10]),
         do.return = T, label.size = 5, pt.size = 0.5)
p <- p[c(1:5, 11, 6:10, 12)]
p <- map2(p, c(names(cell_ids)[1:5], "All expt1", names(cell_ids)[6:10], "All expt2"),
            ~.x + 
            coord_cartesian(c(-50, 50), c(-45, 55)) + 
            labs(title = .y) +
            theme(legend.position = "none"))

plot_grid(plotlist = p, nrow = 2, align = "hv")
```

## Cluster identification

  Unsupervised clustering was performed to identify transcriptionally distinct cell populations. A graph-based algorithm was used that builds a k-nearest neighbor (KNN) graph on the euclidean distances calculated from principal components, weights each edge based on the local neighborhood using jaccard statistics, then prunes the graph to select clusters using an optimization function. The graph based algorithm is implemented in the Seurat R package.  Clusters are visualized using TSNE, but the cluster assignments are based on the first 15 principal components.
  
```{r find_markers, fig.width = 10, fig.height = 10}
atcells <- SetAllIdent(atcells, "res.0.8")
TSNEPlot(atcells, 
         do.label = T, label.size = 10)

```

  The clustering algorithm identified additional clusters than the first experiment alone, which is expected with having many more cells. Overall the algorithm nicely partions the data. 

## Classifying the cell type for each cluster {.tabset .tabset-fade}

  Plotted below are a set of known marker genes that help to identify each cell population. Classifications taken from
http://www.nature.com/nature/journal/v507/n7491/fig_tab/nature12930_ST1.html
http://www.atsjournals.org/doi/pdf/10.1165/rcmb.2017-0037MA
http://www.jci.org/articles/view/68782

Click on the tabs to view other markers

```{r,  fig.width = 10, fig.height= 10}

control_markers <- c(
  "Ager", # mouse homologue of RAGE
  "Aqp5",
  "Pdpn", # T1-Alpha
  "Scgb1a1",
  "Scgb3a1")

basal_cells <- c(
  "Krt5",
  "Krt14",
  "Krt15",
  "Trp63"
)

ciliary_cells <- c(
  "Foxj1"
)

ae2 <- c(
  "Sftpa1", #SPA
  "Sftpc",
  "Abca3",
  "Muc1",
  "Lyz2",
  "Lamp3"
  )


g2_macro <- c(
  "Col3a1",
  "Col1a2",
  "Col1a1",
  "Fcer1g",
  "Cd68",
  "Cd53",
  "Top2a",
  "Cdk1",
  "Mki67"
)

transdiff <- c(
  "Cav1",
  "Cav2",
  "Pdpn",
  "Hopx",
  "Sfn",
  "Epcam"
)
```

### ATI markers
```{r, fig.width=10, fig.height=10}
FeaturePlot(atcells, control_markers, pt.size = .25)
```

### ATII markers
```{r, fig.width=10, fig.height=10}
FeaturePlot(atcells, ae2, pt.size = .25)
```

### Basal Cell markers
```{r, fig.width=10, fig.height=10}
FeaturePlot(atcells, basal_cells, pt.size = .25)
```

### Ciliary Cell markers
```{r, fig.width=10, fig.height=10}
FeaturePlot(atcells, ciliary_cells, pt.size = .25)
```

### Other population markers
```{r, fig.width=10, fig.height=10}
FeaturePlot(atcells, g2_macro, pt.size = .25)
```

### Transdifferentiation
```{r, fig.width=10, fig.height=10}
FeaturePlot(atcells, transdiff, pt.size = .25)
```

## Labeled Cell types

Based on these data I proposed the following classification (TSNE plotted again below):

Cluster |  Classification  | Marker Gene Expression 
-------- |  ------------  | ----------------
1,11,3,0,4,2 | Injured ATII cells | high levels of SPC 
7, 6 | Uninjured ATII cells | high levels of SPC 
5 | Transdifferentiating ATII | Low ATII markers, some ATI marker expression (Pdpn, Aqp5, Ager), Hopx expression 
10 | Transdifferentiating ATII  | Low ATII markers 
12 | ATII cells in G2/M | Mki67 
15 | ATI cells | Hopx, Pdpn, Aqp5  
5 | ATI cells | high levels of Pdpn, Aqp5, and P63
9 | Club cells | Express high levels of Secretoglobin (scgb1a1), also contains Scgb1a1+/SPC+ population
8 | Basal Cells | Trp63 Krt15 Krt5
13 | Macrophages | Cd53
14 | Endothelial/Fibroblast | Col1a1
16 | Ciliary Cells | Foxj1 


```{r fig.width = 10, fig.height = 10}
atcells <- SetAllIdent(atcells, "res.0.8")
TSNEPlot(atcells, 
         do.label = T, label.size = 10)
```

For this analysis I will focus my analysis on the transdifferentiating populations, as they are the most interesting. To simplify the analysis, at this point I will merge the clusters corresponding to the injured type II cells that are not transdifferentiating. The three transdifferentiating populations are labeled TD1, TD2, TD3. 

```{r, results="asis", eval = F}
Cluster |  Classification  | Notes
-------- |  ------------  | ----------------
1,11,3,0,4,2 | Injured ATII cells | high levels of SPC
7, 6 | Uninjured ATII cells | high levels of SPC
5 | Transdifferentiating ATII | Low ATII markers, some ATI marker expression (Pdpn, Aqp5, Ager), Hopx expression 
10 | Transdifferentiating ATII  | Low ATII markers,  
12 | ATII cells in G2/M | Mki67
15 | ATI cells | Hopx, Pdpn, Aqp5, 
5 | ATI cells | high levels of Pdpn, Aqp5, and P63
9 | Club cells? | Express high levels of Secretoglobin (scgb1a1), also contains Scgb1a1+/SPC+ population
8 | Basal Cells | Trp63 Krt15 Krt5
13 | Macrophages | Cd53
14 | Endothelial/Fibroblast | Col1a1
Ciliary cells (Foxj1+ cells) were not identified in the dataset.
```

```{r, fig.width = 10, fig.height = 10, eval = F}
replace_id <- function(vec, x, y) {
  for(i in seq_along(x)){
    vec[vec == x[i]] <- y
  }
  vec
}

# merge injured type II cells
clusters_to_merge <- c("1", "11", "3", "0", "4", "2")
cluster_ids <- atcells@data.info$res.0.8
a <- replace_id(cluster_ids, clusters_to_merge, "20")
new_ids <- data.frame(row.names = atcells@cell.names, 
                new_ids = as.character(a))
atcells <- AddMetaData(atcells, new_ids)

#merge uninjured type II cells
clusters_to_merge <- c("7", "6")
cluster_ids <- atcells@data.info$new_ids
cluster_ids <- as.character(cluster_ids)
a <- replace_id(cluster_ids, clusters_to_merge, "22")
a <- match(a, unique(a))
new_ids <- data.frame(row.names = atcells@cell.names, 
                new_ids = as.character(a))
atcells <- AddMetaData(atcells, new_ids)

atcells <- SetAllIdent(atcells, "new_ids")

TSNEPlot(atcells, 
        colors.use = brewer.pal(n = 11, "Paired"), 
         do.label = T, label.size = 16,
        pt.size = 3)


renames <- c(
  "Endothelial",
  "Basal",
  "Club",
  "Ciliary",
  "Type I",
  "Type II",
  "Macrophages",
  "TD 1",
  "TD 2",
  "Injured\nType II",
  "TD 3")

names(renames) <- c(as.character(1:11))
ids <- atcells@data.info$new_ids
ids <- as.character(ids)
labeled_ids <- renames[ids] %>% unname()


labeled_ids <- data.frame(
  row.names = atcells@cell.names,
  labeled_clusters = labeled_ids)

atcells <- AddMetaData(atcells, labeled_ids)
```

```{r, fig.width = 10, fig.height = 10}
# remove newline from type II label
atcells <- SetAllIdent(atcells, "labeled_clusters")

ids <- atcells@data.info$labeled_clusters
levels(ids)[levels(ids)=="Injured\nType II"] <- "Injured Type II"
labeled_ids <- as.character(ids)

labeled_ids <- data.frame(
  row.names = atcells@cell.names,
  labeled_clusters = labeled_ids)

atcells <- AddMetaData(atcells, labeled_ids)

TSNEPlot(atcells, 
        colors.use = brewer.pal(n = 11, "Paired"), 
         do.label = T, label.size = 10)
```

## Gene expression per cluster

Next we will determine genes enriched in each sample by comparing gene expression in each sample to all other samples. Plotted below are the top 10 enriched genes detected in each sample for all cell transcriptomes (Yellow is high, purple is low).

```{r}
atcells_cluster_markers %>% 
  group_by(cluster) %>% 
  top_n(10, avg_diff) -> top10

atcells_merged_markers %>% 
  group_by(cluster) %>% 
  top_n(10, avg_diff) -> top10_merged

```

```{r, fig.width = 20, fig.height= 20, eval = F }
DoHeatmap(atcells, 
          genes.use = top10$gene, 
          order.by.ident = TRUE, 
          slim.col.label = TRUE, cexRow = 0.75, 
          remove.key = TRUE,  margins = c(8, 8))
```



```{r heatmap, fig.width = 20, fig.height= 20 }

cells <- atcells@data.info$labeled_clusters %in% c("TD1", "TD2", "TD3", "Type I")
cells <- rownames(atcells@data.info[cells, ])
DoHeatmap(atcells, 
          genes.use = top10_merged$gene, 
          order.by.ident = TRUE, 
          slim.col.label = TRUE, cexRow = 0.75, 
          remove.key = TRUE,  margins = c(8, 8))
```
 
## Top genes per cell type {.tabset .tabset-fade}
  Plotted are the abundances of the top marker genes detected per sample (red is high, yellow is low) projected onto the TSNE map. 
  
```{r genes_enriched_per_cluster,  eval = T }
top4_genenames <- split(top10_merged, 
                        top10_merged$cluster) %>% 
  map(., ~.x[1:4, ]$gene)

```

```{r tsnes_per_cluster, fig.width = 10, fig.height= 10, results = "asis"}

for(i in seq_along(top4_genenames)){
  cat('\n### ', names(top4_genenames)[i], '\n', sep = "")
  FeaturePlot(atcells, top4_genenames[[i]], pt.size = 0.5)
  cat('\n')
}
```



## Distribution of cells per cluster

  Overall the cell types detected are pretty similar between experiments. 
```{r cluster_distribution, fig.width = 16, fig.height = 10}
cluster_ids <- atcells@ident
cell_ids <- atcells@data.info$orig.ident

cluster_summary <- data_frame(id = cell_ids, cluster = cluster_ids)
cluster_summary <- group_by(cluster_summary, id, cluster) %>% summarize(cells = n())

ggplot(cluster_summary, aes(cluster, cells, fill = cluster)) +
  facet_wrap(~id, scales = "free_y",nrow = 2) +
  ylab("Number of Cells") +
  scale_fill_brewer(palette = "Paired") +
  geom_bar(stat = "identity") +
  theme(
    axis.text.x = element_blank()
  )
  
```

```{r, eval = F}
# calculate proportion
cluster_summary <- cluster_summary %>% 
  group_by(id) %>% 
  mutate(total = sum(cells), 
         proportion = cells / total) %>%
  select(-total)

# make xperiment variable
cluster_summary <- cluster_summary %>% 
  mutate(expt = str_extract(id, "expt[12]$"),
         sample = str_split(id, "expt", simplify = T)[, 1])

# spread out
cluster_summary <- cluster_summary %>% 
  ungroup() %>% 
  select(-id, -cells) %>% 
  spread(expt, proportion)

cluster_summary[is.na(cluster_summary)] <- 0

ggplot(cluster_summary, aes(expt1, expt2)) +
  geom_point(aes(colour = cluster)) +
  ylab("Number of Cells")
```

## Cell cycle {.tabset .tabset-fade}

The cell cycle state of the cells can be inferred using the cyclone function in scater. A pretrained dataset from mouse embryonic stem cells was used for classification. Similar to the first experiment 1 cluster of transdifferentiating cells are cleary classified as proliferating.

### Stage Classification
```{r, fig.width = 10, fig.height = 10}

atcells <- SetIdent(atcells, ident.use = atcells@data.info$phase)
TSNEPlot(atcells, colors.use = brewer.pal(n = 12, "Paired"), do.label = F)

``` 
 
### TSNE by Sample
```{r, fig.width = 10, fig.height = 10}
atcells <- SetIdent(atcells, 
                    ident.use = atcells@data.info$labeled_clusters)
TSNEPlot(atcells, colors.use = brewer.pal(n = 12, "Paired"), 
         do.label = T, label.size = 12)
```

## Find Transcription Factors {.tabset .tabset-fade}
 
 To identify potential important regulators of transdifferentiation, transcription factors will be identified that are enriched in each cell type. A database of known TFs was queried (taken from this [paper](https://academic.oup.com/bioinformatics/article/29/19/2519/190534/TFcheckpoint-a-curated-compendium-of-specific-DNA) in bioinformatics) to select TFs. Shown below are the TFs found in each cluster ranked by enrichment in the cluster compared to all other clusters. 
 
```{r, results = 'hide', message = F, eval = T}
# https://academic.oup.com/bioinformatics/article/29/19/2519/190534/TFcheckpoint-a-curated-compendium-of-specific-DNA

if(!file.exists("TFCheckpoint_download_180515.txt")) {
  download.file("http://www.tfcheckpoint.org/data/TFCheckpoint_download_180515.txt", "TFCheckpoint_download_180515.txt")
}

tfs <- read_tsv("TFCheckpoint_download_180515.txt")
 
# map entrez id to symbol
eid_to_symbol <- select(org.Mm.eg.db, keys = keys(org.Mm.eg.db), columns = c("ENTREZID", "SYMBOL"))
 
eid_to_symbol[["ENTREZID"]] <- as.integer(eid_to_symbol[["ENTREZID"]])

# filter non-mouse tfs, and add in symbol
left_join(tfs, tbl_df(eid_to_symbol), 
          by = c("entrez_mouse" = "ENTREZID")) %>% 
  dplyr::filter(entrez_mouse != 0) -> annotated_tfs #0 is na 

# select out interesting cluster
atcells_merged_markers %>% 
  dplyr::filter(cluster == "TD 1") -> interesting_cluster

# find clusters associated with transcription factors
left_join(atcells_merged_markers, 
          annotated_tfs, by = c("gene" = "SYMBOL")) -> tf_annotated

# find RNA binding proteins, 
# supplemental table3 
# http://www.nature.com/nrg/journal/v15/n12/full/nrg3813.html

#download.file("http://www.nature.com/nrg/journal/v15/n12/extref/nrg3813-s3.xls", "nrg3813-s3.xls")

#rbps <- readxl::read_excel("nrg3813-s3.xls", sheet = 2)

#annotated <- left_join(tf_annotated, rbps, by = c("gene_symbol" = "gene name"))

tf_annotated %>% dplyr::filter(entrez_mouse != 0) %>% 
  dplyr::select(p_val:gene, gene_name) -> tf_info

clusters <- unique(tf_info$cluster)
# reorder to make visualization better
clusters <- clusters[c(7, 8, 9, 10, 11, 1:6)]
```

### TFs enriched in TD 1
```{r}
dplyr::filter(tf_info, cluster == clusters[1]) %>% 
    as.data.frame()
```

### TFs enriched in TD 2
```{r}
dplyr::filter(tf_info, cluster == clusters[2]) %>% 
    as.data.frame()
```

### TFs enriched in TD 3
```{r}
dplyr::filter(tf_info, cluster == clusters[3]) %>% 
    as.data.frame()
```

### TFs enriched in Type I
```{r}
dplyr::filter(tf_info, cluster == clusters[4]) %>% 
    as.data.frame()
```

### TFs enriched in Type II
```{r}
dplyr::filter(tf_info, cluster == clusters[5]) %>% 
    as.data.frame()
```

### TFs enriched in Basal
```{r}
dplyr::filter(tf_info, cluster == clusters[6]) %>% 
    as.data.frame()
```

### TFs enriched in Ciliary
```{r}
dplyr::filter(tf_info, cluster == clusters[7]) %>% 
    as.data.frame()
```

### TFs enriched in Club
```{r}
dplyr::filter(tf_info, cluster == clusters[8]) %>% 
    as.data.frame()
```

### TFs enriched in Endothelial
```{r}
dplyr::filter(tf_info, cluster == clusters[9]) %>% 
    as.data.frame()
```

### TFs enriched in Injured Type II
```{r}
dplyr::filter(tf_info, cluster == clusters[10]) %>% 
    as.data.frame()
```

### TFs enriched in Macrophages
```{r}
dplyr::filter(tf_info, cluster == clusters[11]) %>% 
    as.data.frame()
```

## Find Cell Surface Markers {.tabset .tabset-fade}

  To identify FACS sortable markers of each cell type cell surface proteins will be identified that are enriched in each cell type. A database of known cell surface proteins derived from mass spec data was queried (taken from this [paper](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0121314) in Plos One) to select cell surface markers. Additionally, the  [UniProt](http://www.uniprot.org/uniprot/?query=locations%3A(location%3A%22cell%20membrane%22)%20AND%20organism%3A%22Mus%20musculus%20(Mouse)%20%5B10090%5D%22%20AND%20annotation%3A(type%3Atransmem)&sort=score&columns=id%2Centry%20name%2Creviewed%2Cprotein%20names%2Corganism%2Clength%2Cgenes(PREFERRED))  database was queried to extract putative cell surface proteins. Shown below are the cell surface proteins found in each cluster ranked by enrichment in the cluster. 
  
  The `CSPA category` is a category that is either `high confidence`, `putative` or `unspecific`. If the cell surface marker was not found in the CSPA database, but present in the Uniprot database, then it will not have a CSPA category entry.
 
```{r, eval = F}
# url to download uniprot catagories
"http://www.uniprot.org/uniprot/?query=locations%3A(location%3A%22cell%20membrane%22)%20AND%20organism%3A%22Mus%20musculus%20(Mouse)%20%5B10090%5D%22%20AND%20annotation%3A(type%3Atransmem)&sort=score&columns=id%2Centry%20name%2Creviewed%2Cprotein%20names%2Corganism%2Clength%2Cgenes(PREFERRED)"

# search terms
#locations:(location:"cell membrane") annotation:(type:transmem) AND organism:"Mus musculus (Mouse) [10090]"

# dl date = 08/24/17
```

```{r}

if(!file.exists("S2_File.xlsx")){
  download.file("http://wlab.ethz.ch/cspa/data/S2_File.xlsx", 
                "S2_File.xlsx")
}

cell_surface_markers <- readxl::read_excel("S2_File.xlsx", 
                                           sheet = 2)
uni <- suppressMessages(read_tsv("uniprot.tab.gz"))
filter_cell_surface <- function(df, cell_surface_markers, uniprot) {
  # annotate with CSPA database and uniprot databse
  
  left_join(df, 
            uniprot,
            by = c("gene" = "Gene names  (primary )")) %>% 
    dplyr::select(-(Entry:Status), -(Organism:Length)) %>% 
    dplyr::mutate(Uniprot_tm = ifelse(is.na(`Protein names`), 
                                      NA,
                                      "yes")) -> uni_annotated
  
  left_join(uni_annotated, 
            cell_surface_markers, 
            by = c("gene" = "ENTREZ gene symbol")) -> cf_annotated
  
  dplyr::mutate(cf_annotated,
                `UniProt cell surface` = ifelse(!is.na(Uniprot_tm),
                                                "yes",
                                                `UniProt cell surface`),
                `UP_Protein_name` = ifelse(!is.na(`Protein names`),
                                                `Protein names`,
                                                `UP_Protein_name`)) -> cf_annotated
  
  cf_annotated <- dplyr::select(cf_annotated, 
                                -(`Protein names`:Uniprot_tm))
  dplyr::filter(cf_annotated,
                !is.na(`CSPA category`) | !is.na(`UniProt cell surface`)) %>% 
    dplyr::select(-organism, 
                  -ID_link,
                  -UP_entry_name,
                  -(ENTREZ_gene_ID:`Phobius TM predicted yes/no`)) -> res
  
  #remove redundant annotatiosn due to multiple gene descriptions
  grp_cols <- colnames(res)
  grp_cols <- grp_cols[grp_cols != "UP_Protein_name"]
  group_by_at(res, grp_cols) %>% 
    summarize(UP_Protein_name = dplyr::first(UP_Protein_name)) %>% 
    arrange(p_val) %>% 
    ungroup()
}


filter_cell_surface(atcells_merged_markers, 
          cell_surface_markers, 
          uni) -> cf_annotated

```

### Surface Proteins enriched in TD 1
```{r}
dplyr::filter(cf_annotated, cluster == clusters[1]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in TD 2
```{r}
dplyr::filter(cf_annotated, cluster == clusters[2]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in TD 3
```{r}
dplyr::filter(cf_annotated, cluster == clusters[3]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in Type I
```{r}
dplyr::filter(cf_annotated, cluster == clusters[4]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in Type II
```{r}
dplyr::filter(cf_annotated, cluster == clusters[5]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in Basal
```{r}
dplyr::filter(cf_annotated, cluster == clusters[6]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in Ciliary
```{r}
dplyr::filter(cf_annotated, cluster == clusters[7]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in Club
```{r}
dplyr::filter(cf_annotated, cluster == clusters[8]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in Endothelial
```{r}
dplyr::filter(cf_annotated, cluster == clusters[9]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in Injured Type II
```{r}
dplyr::filter(cf_annotated, cluster == clusters[10]) %>% 
    as.data.frame()
```

### Surface Proteins enriched in Macrophages
```{r}
dplyr::filter(cf_annotated, cluster == clusters[11]) %>% 
    as.data.frame()
```


##  Find Surface markers marking TD populations, not in non-TD Type II {.tabset .tabset-fade }

Ideally a surface marker for sorting would be able to isolate the TD populations. The Type II cells are marked with GFP, so we only need to find a marker that distinguishes the TD type II cells from the non-TD type II cells. Shown below are cell surface proteins that are enriched compared to non-TD cell populations in TD 1, TD 2, TD 3, or in all TD cells.

```{r, eval = F}
td1 <- FindMarkers(atcells, c("TD 1"), 
                                  c("Injured\nType II", 
                                    "Type II"), only.pos = F)

td2 <- FindMarkers(atcells, c("TD 2"), 
                                  c("Injured\nType II", 
                                    "Type II"), only.pos = F)
                   
td3 <- FindMarkers(atcells, c("TD 3"), 
                                  c("Injured\nType II", 
                                    "Type II"), only.pos = F)

                                      
td <- FindMarkers(atcells, c("TD 1", "TD 2", "TD 3"), 
                                  c("Injured\nType II", 
                                    "Type II"), only.pos = F)
                  
tds <- list(td1,
            td2,
            td3,
            td)

tds <- map(tds, ~tibble::rownames_to_column(.x, "gene") %>% 
             as_data_frame())


map(tds, ~filter_cell_surface(.x, 
                              cell_surface_markers,
                              uni)) -> tds_annotated

map2(tds_annotated, 
     c("csm_td1.txt", 
       "csm_td2.txt",
       "csm_td3.txt",
       "csm_tds.txt"),
     ~write_tsv(.x, .y))

map2(tds, 
     c("td1_markers.txt", 
       "td2_markers.txt",
       "td3_markers.txt",
       "td123_markers.txt"),
     ~write_tsv(.x, .y))

```

```{r, message=F}
tds <- map(c("csm_td1.txt", 
       "csm_td2.txt",
       "csm_td3.txt",
       "csm_tds.txt"), ~read_tsv(.x))

```
### Enriched in TD1
```{r, eval = T}
tds[[1]]
```

### Enriched in TD2
```{r, eval = T}
tds[[2]]
```

### Enriched in TD3
```{r, eval = T}
tds[[3]]
```

### Enriched in All TDs
```{r, eval = T}
tds[[4]]
```

## Surface Markers Enriched in TD populations {.tabset .tabset-fade}

Here is a quick look at a few markers that are strongly enriched in the TD1 popultation. 
```{r}
cool_genes <- c(
  "Cldn4",
  "Plb1",
  "Ifitm3",
  "Eno1",
  "Fn1",
  "Ntm",
  "Ifngr1",
  "Mfge8",
  "Emp2")
```

```{r, fig.width = 10, fig.height = 10, results='asis'}
for(i in seq_along(cool_genes)){
  cat('\n### ', cool_genes[i], '\n', sep = "")
  FeaturePlot(atcells, cool_genes[i])
  VlnPlot(atcells, cool_genes[i])
  cat("\n")
}
```




## Find TFs marking TD populations, not in non-TD Type II or Type I {.tabset .tabset-fade }

Determining if there are TFs that distinguish the TD1 or TD3 population from type I or type II cells  

```{r, eval = F}
td1_tf <- FindMarkers(atcells, c("TD 1"), 
                                  c("Type I", "Injured\nType II", 
                                     "Type II"), only.pos = F)

td3_tf <- FindMarkers(atcells, c("TD 3"), 
                                  c("Type I", "Injured\nType II", 
                                     "Type II"), only.pos = F)

                                      
td13_tf <- FindMarkers(atcells, c("TD 1", "TD 3"), 
                                  c("Type I", "Injured\nType II", 
                                    "Type II"), only.pos = F)
             

tfs <- list(td1_tf,
            td3_tf, 
            td13_tf)

tfs <- map(tfs, ~tibble::rownames_to_column(.x, "gene") %>% 
             as_data_frame())

tfs_annotated <- map(tfs, ~left_join(.x, 
          annotated_tfs, by = c("gene" = "SYMBOL")))

tfs_annotated <- map(tfs_annotated, 
                     ~.x %>% 
             dplyr::filter(entrez_mouse != 0) %>% 
  dplyr::select(gene:pct.2, gene_name))


map2(tfs_annotated, 
     c("tfs_td1.txt", 
       "tfs_td3.txt",
       "tfs_td13.txt"),
     ~write_tsv(.x, .y))

map2(tfs, 
     c("td1_notype1_markers.txt", 
       "td3_notype1_markers.txt", 
       "td13_notype1_markers.txt"),
     ~write_tsv(.x, .y))

```

```{r, message=F}
tfs <- map(c("tfs_td1.txt", 
       "tfs_td3.txt",
       "tfs_td13.txt"), ~read_tsv(.x))

```
### Enriched in TD1
```{r, eval = T}
tfs[[1]]
```

### Enriched in TD3
```{r, eval = T}
tfs[[2]]
```

### Enriched in TD1 + TD3
```{r, eval = T}
tfs[[3]]
```


## TFs Enriched in TD populations {.tabset .tabset-fade}

Interesting Tfs based on expression. Strangly `Eno1` is annotated as a cell
surface marker and a transcription factor.

```{r}
cool_genes <- c(
  "Sox4",
  "Trim47",
  "Nfkbia",
  "Nfkbie",
  "Nfkb2",
  "Relb",
  "Ran",
  "Tead2",
  "Crip2")
```

```{r, fig.width = 10, fig.height = 10, results='asis'}
for(i in seq_along(cool_genes)){
  cat('\n### ', cool_genes[i], '\n', sep = "")
  FeaturePlot(atcells, cool_genes[i])
  VlnPlot(atcells, cool_genes[i])
  cat("\n")
}
```



