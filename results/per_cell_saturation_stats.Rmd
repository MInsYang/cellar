---
title: "examine per cell reads versus umis"
author: "Kent Riemondy RBI"
date: "March 15, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_chunk$set(message = FALSE)
```

## Goal
  To determine the sequencing saturation per cell rather than as a bulk estimate. This metic is informative for determining which cell populations are not adequetely sampled in a large scale single cell RNA-Seq experiment. Additionally for subsampling protocols this metric will likley be critical for selecting the protocol depth of additional sequencing. 
  
## Approach
  The [10x cellranger pipeline](https://support.10xgenomics.com/single-cell/software/pipelines/latest/what-is-cell-ranger) outputs a molecule_info.h5 file in [HDF5 format](https://en.wikipedia.org/wiki/Hierarchical_Data_Format), which contains information that is used to calculation sequencing saturation in bulk. 
  
According to their docs:

Column | Type	| Description
------ | ---- | --------
barcode	| uint64	| 2-bit encoded processed cell-barcode sequence.
barcode_corrected_reads	| uint32	| Number of reads within this putative molecule that had their cell-barcode corrected.
conf_mapped_uniq_read_pos	| uint32	| Number of unique read mapping positions associated with this putative molecule.
gem_group	| uint8	| Integer label that distinguishes data coming from distinct 10x GEM reactions (such as different channels or chips).
gene	| uint32	| A zero-based index into the gene_ids field (see next section), indicating the gene to which this putative molecule was mapped. When set to the maximum gene index + 1, this row describes reads that did not map confidently to any gene.
genome	| uint32	| A zero-based index into the genome_ids field (see next section), indicating the genome to which this putative molecule was mapped. When set to the maximum genome index + 1, this row describes reads that did not map confidently to any genome.
nonconf_mapped_reads	| uint32	| The number of reads with this cell-barcode and UMI that mapped to the genome but did not map confidently to any gene.
reads	| uint32	| Number of reads that confidently mapped to this putative molecule.
umi	| uint32	| 2-bit encoded processed UMI sequence.
umi_corrected_reads	| uint32	| Number of reads within this putative molecule that had their UMI corrected.
unmapped_reads	| uint32	| The number of reads with this cell-barcode and UMI that did not map to the genome.
Molecule reference columns

In addition, the molecule info has a few datasets corresponding to the reference transcriptome(s) associated with this analysis.

Column |	Type |	Description
------- | -------- | --------
gene_ids	| string	| The Ensembl gene IDs contained in this reference. The gene column defined in the previous section is an index into this array.
gene_names	| string	| The common gene symbol associated with each of the above gene_ids.
genome_ids |	string |	The list of genomes represented in this reference. In most cases, this will be a single genome. The genome column defined in the previous section is an index into this array.

The cell-barcode and UMI sequences are 2-bit encoded as follows:

Each pair of bits encodes a nucleotide (0="A", 1="C", 2="G", 3="T").
The least significant byte (LSB) contains the 3'-most nucleotides.
The most significant bit is set if the sequence contained an 'N'.

## decoding the 2bit dna seqs

The cellrangerRKit is equipped with a function `load_molecule_info()` which will decompress the `hdf5` file and read it into a data.table. This works fine for quick analysis, but the barcode and umi sequences are 2bit encoded, and need to be decoded. 

```{r show_data, message = F, warning = F}
library(cellrangerRkit)
library(dtplyr)
library(dplyr)
#gbm <- load_cellranger_matrix("~/Projects/10x_scRNA/data/Jordan/Brett_1/")
#analysis <- load_cellranger_analysis_results("~/Projects/10x_scRNA/data/Jordan/Brett_1/")
#gbm <- load_molecule_info(gbm = gbm) #load from h5 file
#dat <- gbm@molecule_info #extracted as a data.table 
#dat ## can work with using dplyr verbs thanks to dtplyr
```

  The barcode and umi are encoded in a integer64 object. Here's the python code in cell ranger that encode/decodes the object. 



```{python decode_int64_barcode, eval = T}
import numpy as np
NUCS = ['A', 'C', 'G', 'T']
NUCS_INVERSE = {'A':0, 'C':1, 'G':2, 'T':3}

def compress_seq(s, bits=64):
    """ Pack a DNA sequence (no Ns!) into a 2-bit format, in a 64-bit uint """
    """ Most significant bit is set if there was an error """
    assert len(s) <= (bits/2 - 1)
    result = 0
    for nuc in s:
        if not nuc in NUCS_INVERSE:
            return 1L << (bits - 1)
        result = result << 2
        result = result | NUCS_INVERSE[nuc]
    return result

def decompress_seq(x, length, bits=64):
    x = np.uint64(x)
    assert length <= (bits/2 - 1)
    if x & (1L << (bits-1)):
        return 'N' * length
    result = bytearray(length)
    for i in xrange(length):
        result[(length-1)-i] = NUCS[x & np.uint64(0b11)]
        x = x >> np.uint64(2)
    return str(result)
    
a = compress_seq("ATCG")    
print(a)
b = decompress_seq(a, 4)
print(b)
```

Here's the R code from the cellrangerkit for compressing the sequence which is used for comparing the count matrix barcode id's to the hdf5 file. 

```{r compress, eval = T}
#' Compress a vector of sequences into 2-bit representation
#'
#' Compress a vector of sequences into integer64 objects containing
#' a 2-bit representation. Ns are not allowed
#' @param seqs Vector of nucleotide sequences to compress
#' @return A vector of integer64 objects
compress_sequences <- function(seqs) {
  if (any(grepl('[^ACGT]', seqs))) {
    stop("At least one sequence contains Ns")
  }
  nuc_to_int <- as.integer(0:3)
  names(nuc_to_int) <- c('A', 'C', 'G', 'T')

  chars <- do.call(rbind, strsplit(seqs, ''))
  nuc_ints <- matrix(nuc_to_int[chars], nrow=length(seqs))
  result <- integer64(length(seqs))
  for(i in 1:ncol(nuc_ints)) {
    result <- result * as.integer(4) + nuc_ints[,i]
  }

  result
}
```

I wrote a function `decompress_sequences()` based on the python code above that can handle the decompression. it's not optimized but gets the job done. 

```{r custom_decompressing}
#write a custom decompressing function in R

#' decompress the 10x encoded barcodes. 
#' @param seqs_int64 Vector of int64 2bit encoded sequences to decompress
#' @param lens Length of compressed barcode (int)
#' @return A vector of DNA sequences

decompress_sequences <- function(seqs, lens){
  # hacky and takes about 15 seconds per 1e6  sequences
  bit_code <- c('A', 'C', 'G', 'T')
  names(bit_code) <- c("00", "01", "10", "11")

  b <- as.bitstring(seqs)
  b <- do.call(rbind, strsplit(b, ""))
  nbit <- lens * 2
  nbit_pos <- 64 - (nbit - 1)
  b <- b[, nbit_pos:64]
  pos <- seq(1, nbit, by = 2)
  result = ""
  for(i in pos){
     x <- paste0(b[, i], b[, (i + 1)])
     x_n <- bit_code[x]
     result <- paste0(result, x_n)
  }
  result
}

seqs <- c("ATCG", "GGAT", "CTGA", "TGAC")
seqs_binary <- compress_sequences(seqs)
out_seqs <- decompress_sequences(seqs_binary, 4)
all(seqs == out_seqs)
```


## Per cell sequencing saturation

Next I'll look at the duplication rate across all of the datasets, and plot the saturation metrics per cell on a TSNE

```{r utils}
library(purrr)

load_dat <- function(sample_id, genome){
  gbm <- load_cellranger_matrix(paste0("~/Projects/10x_scRNA/data/", sample_id), genome = genome)
  gbm <- load_molecule_info(gbm = gbm) #load from h5 file
  dat <- gbm@molecule_info #extracted as a data.table 
  dat
}

get_stats <- function(data_object, analysis_object){
  data_object  %>% 
  group_by(seqs) %>% 
  summarize(total_umis = n(), total_reads = as.integer(sum(reads))) %>% 
  as_data_frame() %>% 
  mutate(dup_rate = 1 - (total_umis / total_reads)) %>%  
  arrange(desc(total_umis)) %>% 
  ungroup() -> dat_stats 
  
  inner_join(dat_stats, analysis_object$tsne, by = c("seqs" = "Barcode")) %>% 
  rename(cDNA_duplication_rate = dup_rate) %>% 
  mutate(average_duplication_rate = (1 - (sum(total_umis) / sum(total_reads)))) -> res
  res
}

plot_tsne <- function(dat){
  ggplot(dat, aes(TSNE.1, TSNE.2, colour = cDNA_duplication_rate)) + 
  geom_point() +
  facet_wrap(~expt + 
               paste0("Saturation = ", signif(average_duplication_rate, 3))) +
  coord_equal() +
  theme_bw() +
  theme(legend.position = "top")
}
```

```{r run_analysis_fxn}

run_saturation_analysis <- function(samples, genomes){
  # input list of samples and list of associated genomes
  # load the data
  dat <- map2(samples, genomes, ~load_dat(.x, .y))
  names(dat) <- samples %>% unlist() %>% basename
  analysis <- map(samples, ~load_cellranger_analysis_results(paste0("~/Projects/10x_scRNA/data/", .x)))
 
  # get unique barcodes (~100k) 
  seqs <- map(dat, ~select(.x, barcode) %>% unique())

  # Decode the barcode slow!
  seqs <- map(seqs, ~mutate(.x, seqs = decompress_sequences(barcode, 16)))

  # join seqs with dat
  dat <- map2(dat, seqs, ~inner_join(.x, .y, by = "barcode"))

  # append to gem Id to barcode seq to match matrix colnames
  dat <- map(dat, ~mutate(.x, seqs = paste0(seqs, "-", gem_group)))
  
  # merge TSNE data 
  stats <- map2(dat, analysis, ~get_stats(.x, .y))
  # merge all experiments
  stats <- bind_rows(stats, .id = "expt")
  
  plots <- plot_tsne(stats)
  plots
}
```

## Craig_Jordan_expt

```{r Craig_Jordan_plots}
samples <- list(
  "Jordan/Brett_1", "Jordan/Brett_2", "Jordan/Brett_3"
)
genomes <- c(rep("GRCh38", 3))

plot <- run_saturation_analysis(samples, genomes)
plot
```

## John_Cambier_expt

```{r John_Cambier_plots}
samples <- list(
  "Cambier_BND2", "Cambier_MN2"
)
genomes <- c(rep("GRCh38", 2))

plot <- run_saturation_analysis(samples, genomes)
plot
```

# Control_expt

```{r control_plots, cache.lazy= FALSE}
samples <- list(
  "control", "control"
)
genomes <- c("hg19", "mm10")

dat <- map2(samples, genomes, ~load_dat(.x, .y))
names(dat) <- genomes %>% unlist()
analysis <- map(samples, ~load_cellranger_analysis_results(paste0("~/Projects/10x_scRNA/data/", .x)))
 
# get unique barcodes (~100k) 
seqs <- map(dat, ~select(.x, barcode) %>% unique())

# Decode the barcode slow!
seqs <- map(seqs, ~mutate(.x, seqs = decompress_sequences(barcode, 16)))

# join seqs with dat
dat <- map2(dat, seqs, ~inner_join(.x, .y, by = "barcode"))

# append to gem Id to barcode seq to match matrix colnames
dat <- map(dat, ~mutate(.x, seqs = paste0(seqs, "-", gem_group)) %>% tbl_df()) 

# get matrix to run TSNE
all_dat <- map2(samples, genomes, 
                ~load_cellranger_matrix(paste0("~/Projects/10x_scRNA/data/", .x), genome = .y))

# run tsne
library(Rtsne)

get_tsne <- function(x){
  exprs_dat <- exprs(x)
  exprs_dat <- as.matrix(exprs_dat)
  
  # find variable genes (top 1000?) and plot tsne (code modified from scater::plotTSNE)
  row_variance <- matrixStats::rowVars(exprs_dat)
  ngenes <- min(1000, length(row_variance))
  var_genes <- order(row_variance, decreasing = TRUE)[seq_len(ngenes)]
  exprs_to_plot  <- exprs_dat[var_genes, ]     
  
  #drop low variance genes
  keep_feature <- (matrixStats::rowVars(exprs_to_plot ) > 0.001)
  keep_feature[is.na(keep_feature)] <- FALSE
  exprs_to_plot <- exprs_to_plot[keep_feature, ]
  
  #scale data and compute tsne
  exprs_to_plot <- t(scale(t(exprs_to_plot), scale = T))
  
  tsne_out <- Rtsne::Rtsne(t(exprs_to_plot),
                            initial_dims = 12,
                            perplexity = 30)
  
  tsne_out_dat <- data_frame(seqs = colnames(exprs_dat), 
                         TSNE.1 = tsne_out$Y[, 1], 
                         TSNE.2 = tsne_out$Y[, 2])
  tsne_out_dat
}

tsne_dat <- map(all_dat, ~get_tsne(.x))

tsne_dat <- map2(dat, tsne_dat, ~inner_join(.x, .y, by = "seqs"))

tsne_stats <- function(x) {
  x  %>% 
  group_by(seqs, TSNE.1, TSNE.2) %>% 
  summarize(
    total_umis = n(), 
    total_reads = sum(as.numeric(reads))) %>% 
  mutate(dup_rate = 1 - (total_umis / total_reads)) %>%  
  arrange(desc(total_umis)) %>% 
  ungroup() %>% 
  rename(cDNA_duplication_rate = dup_rate) %>% 
  mutate(average_duplication_rate = (1 - (sum(as.numeric(total_umis)) / sum(total_reads)))) %>% 
  select(seqs, TSNE.1, TSNE.2, cDNA_duplication_rate, average_duplication_rate, total_umis)
}

tsne_dat <- map(tsne_dat, ~tsne_stats(.x))
tsne_dat <- bind_rows(tsne_dat, .id = "expt")
plot_tsne(tsne_dat)
```

```{r duplication_rate_doublets}
dblets <- readr::read_csv("~/Projects/10x_scRNA/data/control/outs/analysis/gem_classification.csv")

dblets <- inner_join(tsne_dat, dblets, by = c("seqs" = "barcode"))

ggplot(dblets, aes(call, cDNA_duplication_rate)) +
  geom_boxplot()

ggplot(dblets, aes(hg19, mm10, colour = cDNA_duplication_rate, shape = call)) + geom_point()
```



## Pick cells


5' P5-R1-Barcode: AATGATACGGCGACCACCGAGATCT-ACACTCTTTCCCTACACGACGCTCTTCCGATCT-NNNNNNNNNNNNNNNN 
3' P7-SI-R2: CAAGCAGAAGACGGCATACGAGAT-NNNNNNNN-GTGACTGGAGTTCAGACGTGTGCTCTTCCGATC

```{r oligo_picker}
p5_seq <- "AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT"
```

