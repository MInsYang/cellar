---
title: "Jordan lab AML-PBMC single cell RNA-Seq expt."
author: "Kent Riemondy and Austin Gillen RBI"
output:
  html_document:
    toc: true
    toc_float: true
    toc_collapsed: false
    fig_caption: yes
    fig_retina: 1 
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
#knitr::opts_chunk$set(cache.lazy = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```



```{r libs, message=FALSE, warning=FALSE, echo=FALSE}
library(Seurat)
library(readr)
library(tidyr)
library(plyr)
library(dplyr)
library(stringr)
library(ggplot2)
library(cowplot)
library(RColorBrewer)
library(Matrix)
library(purrr)
```


## Experiment Summary
 
  
Sample | Treatment
-------- | ----------  
Sample 1 | Pbmcs from a patient at AML diagnosis
Sample 2 | Pbmcs from a patient at remission
Sample 3 | Pbmcs from a patient at relapse

"The three samples are the same patient- sample 1 is diagnosis, sample 2 is remission and sample 3 is relapse. There are some immunophenotypic changes that we see- appearance of CD56 on malignant cells and some genetic changes â€“ appearance of a CEBPA mutation. The hope is the RNA seq will pick out the malignant cells and there will be a disappearance/replacement with lymphocytes(remission) and a re-emergence(relapse)."


```{r Jordan_data, eval = T}
pbmc <- Seurat::Read10X("~/Projects/10x_scRNA/data/Jordan/Brett_123/outs/filtered_gene_bc_matrices_mex/GRCh38/")
```

```{r, eval = T, message = F, results = 'hide', warning=F}
pbmc <- new("seurat", raw.data = pbmc)

pbmc <- Setup(pbmc, min.cells = 5, min.genes = 250, do.logNormalize = T, total.expr = 1e4, project = "Jordan", names.field = 2, names.delim = "-")

samples_lookup <- c("Diagnosis", "Remission", "Relapse")
names(samples_lookup) <- c(1, 2, 3)

og_vals <- pbmc@ident
new_vals <- samples_lookup[og_vals]
pbmc@ident <- plyr::mapvalues(pbmc@ident, from = og_vals, to = new_vals)
```

## QC
  
```{r examine_umi_and_ngenes, cache.lazy=FALSE, fig.width = 10, fig.height = 8, warning = F}
summary_dat <- data_frame(cell = colnames(pbmc@raw.data), 
                          nUMIs = colSums(pbmc@raw.data),
                          nGenes = colSums(pbmc@raw.data > 0))

summary_dat <- separate(summary_dat, cell, c("cellid", "sample"), sep = "-")


summary_dat <- summary_dat %>% mutate(sample = samples_lookup[.$sample])
summary_dat <- summary_dat %>% group_by(sample) %>% dplyr::arrange(desc(nUMIs))

n_cells <- summary_dat %>%  group_by(sample) %>%  summarize(n_cells = n(),
                                                            median_UMIs = median(nUMIs),
                                                            median_Genes = median(nGenes))

knitr::kable(n_cells,
             caption = "Number of cells prior to filtering and summary statistics")

a <- ggplot(summary_dat, aes(sample, log10(nUMIs))) +
  geom_violin(aes(fill = sample)) +
  scale_fill_brewer(palette = "Set1") +
  ylab("Number of UMIs (Log10)") +
  theme(axis.text.x = element_blank())

b <- ggplot(summary_dat, aes(sample, log10(nGenes))) +
    geom_violin(aes(fill = sample)) +
  scale_fill_brewer(palette = "Set1") +
  ylab("Number of Genes (at least 1 UMI) Log10") +
  theme(axis.text.x = element_blank())
plot_grid(a, b)
```

```{r write_matrix, eval =F}
system("mkdir -p count_matrix/")
write_tsv(dat, "count_matrix/all_samples_raw_counts_matrix.txt")
system("gzip count_matrix/all_samples_raw_counts_matrix.txt")
```

```{r utility_fxn}
cell_counts <- function(seurat_object){
  #returns tbl_df with number of cells per sample type in seurat object
  map_df(levels(seurat_object@ident), 
         ~data_frame(sample = .x, 
                     n_cells = length(WhichCells(seurat_object, ident = .x))))
}
```


The percentage of reads aligning to mitochondria is often an indicator of cell quality. Cells that have lysed prior to capture preferentially retain mitochondial RNA, but lose cellular cytoplasmic mRNA. As shown below there is a strong negative correlation with the number of UMIs and the proportion of reads aligning to mitochondria. Cells with less than 15% mitochondrial reads will be retained for further analysis.

```{r QC, cache.lazy=FALSE}
mito.genes <- grep("^MT-", rownames(pbmc@data), value = T)
proportion.mito <- colSums(expm1(pbmc@data[mito.genes, ]))/colSums(expm1(pbmc@data))

pbmc <- AddMetaData(pbmc, proportion.mito, "proportion.mito")
#VlnPlot(pbmc, "nGene")
#VlnPlot(pbmc, "nUMI")
VlnPlot(pbmc, "proportion.mito")
```

```{r qc_mito_problems}
GenePlot(pbmc, "nUMI", "proportion.mito")

```

```{r}
pbmc <- SubsetData(pbmc, subset.name = "proportion.mito", accept.high = 0.15)


```

```{r ngenes_filter}
pbmc <- SubsetData(pbmc, subset.name = "nGene", accept.low = 250)

knitr::kable(cell_counts(pbmc),
             caption = "Number of cells passing an additional filter requiring less than 15% mitochondrial reads and at least 500 genes detected")
```

After filtering the distribution of UMIs, Genes, and Proportion of mitochondrial reads is shown below:

```{r ngenes_post_filter}
VlnPlot(pbmc, "nGene")
VlnPlot(pbmc, "nUMI")
VlnPlot(pbmc, "proportion.mito")

```

```{r regress_out_umi_and_mito, results = 'hide'}
pbmc <- RegressOut(pbmc, latent.vars = c("nUMI", "proportion.mito"))
```

```{r get_variable_genes, results = 'hide'}
pbmc <- MeanVarPlot(pbmc, 
                    fxn.x = expMean, 
                    fxn.y = logVarDivMean, 
                    x.low.cutoff = 0.0125, 
                    x.high.cutoff = 4, y.cutoff = 0.5, do.contour = F, do.plot = F)

length(pbmc@var.genes)

```

```{r PCA_tsne_calc, eval = T, results='hide'}
pbmc <- PCA(pbmc, pc.genes = pbmc@var.genes, do.print = TRUE, pcs.print = 5, genes.print = 5)

pbmc <- ProjectPCA(pbmc)
pbmc <- RunTSNE(pbmc, dims.use = 1:15, do.fast = T, k.seed = 1)
```

## PCA
  To get an overview of the relationships between different cell types, PCA will be used first. Shown below is a plot of the first two prinicipal components computed using highly variable genes (approx ~2500 genes). The first two componenets of the PCA rarely capture all of the variation in the data, as can be seen in the second plot.  
  
```{r plot_pca, eval = T}
PCAPlot(pbmc, 1, 2)
PCElbowPlot(pbmc)
```

```{r, eval = F, message = F, warning = F}
PCHeatmap(pbmc, pc.use = 1:15, cells.use = 2000, do.balanced = TRUE, label.columns = FALSE, use.full = FALSE, do.plot = F)
```

## TSNE projection
  PCA analysis is useful for identifying the most variable dimensions in the dataset. However in single cell datasets there are often many dimensions that are informative for clustering the cells. [TSNE](https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding) is a new non-linear dimensionality reduction algorithm that is particularly well-suited for projecting multidimensional data in two dimensional space. 
  
  Shown below is a TSNE projection of the single cell data, with each cell colored by the sample type. Overall there is quite a large degree of structure in the data with some apparent clusters shared with the samples, and also unique to each sample.
  
```{r plot_TSNE, fig.width = 14, fig.height = 14}
TSNEPlot(pbmc, colors.use = brewer.pal(n = 11, "Paired"))
```

## Potential Confounding Factors
  A challenge with single-cell RNA-Seq is the high degree of technical noise. Variables such as the number of detected genes or UMIs can drive apparent differences in sample transcriptomes. Shown below is the same `TSNE` projection with each cell colored by the number of genes, umis, or percent mitochondria detected. 
  
```{r find_confounding_issues}
FeaturePlot(pbmc, "nGene")
FeaturePlot(pbmc, "nUMI")
FeaturePlot(pbmc, "proportion.mito")
```

## Cluster identification

  Unsupervised clustering was performed to identify transcriptionally distinct cell populations. A graph-based algorithm was used that builds a k-nearest neighbor (KNN) graph on the eucidean distances calculated from principal components, weights each edge based on the local neighboorhod using a jaccard statics, then prunes the graph to select clusters using an optimization function. The graph based algorithm is implemented in the Seurat R package.  Clusters are visualized using TSNE, but the cluster assignments are based on the first 14 principal components.
  
```{r find_markers, fig.width = 14, fig.height = 14, warning=FALSE}
pbmc <- FindClusters(pbmc, 
                     pc.use = 1:14, 
                     k.param = 25, 
                     resolution = 0.6, 
                     print.output = 0, 
                     plot.SNN = F,
                     save.SNN = T, random.seed = 0)

TSNEPlot(pbmc, colors.use = brewer.pal(n = 12, "Paired"), do.label = T, label.size = 10)
```



## Gene expression per cluster

Next we will determine genes enriched in each sample by comparing gene expression in each sample to all other samples. Plotted below are the top 10 enriched genes detected in each sample for all cell transcriptomes (Yellow is high, purple is low).

```{r}
pbmc_markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
pbmc_markers %>% group_by(cluster) %>% top_n(10, avg_diff) -> top10
```

```{r, fig.width = 20, fig.height= 20 }
DoHeatmap(pbmc, genes.use = top10$gene, order.by.ident = TRUE, slim.col.label = TRUE, cexRow = 0.75, remove.key = TRUE,  margins = c(8, 8))
```

  Plotted below are the abundances of the top marker genes detected per sample (red is high, yellow is low) projected onto the TSNE map. 
  
```{r genes_enriched_per_cluster, fig.width = 7.5, fig.height= 7.5, eval = T }
top6_genenames <- split(top10, top10$cluster) %>% map(., ~.x[1:4, ]$gene)

plot_tsnes <- function(x, y) {
  #par(mar=c(0,0,1,0))
  #plot(0,type='n',axes=FALSE,main = y, ylab = "", xlab = "") 
  print(y)
  FeaturePlot(pbmc, x, pt.size = 0.5)
} 

walk2(top6_genenames, names(top6_genenames), ~plot_tsnes(.x, .y))
```

## Classifying the cell type for each cluster

  Plotted below are a set of known marker immune cell genes that help to identify each cell population. Classification based on previous single cell analyses of pbmcs (http://www.nature.com/articles/ncomms14049#f5)
  
```{r,  fig.width = 10, fig.height= 10}
immune_markers <- c(t_cells = "CD3D", cd8_t ="CD8A", cytotoxic_t = "NKG7", dendritic = "FCER1A", monocytes = "S100A8", megakaryocyte = "PF4", b_cell = "CD79A", cd4_4 = "IL7R", monocyte = "CD14")

knitr::kable(data_frame(populations = names(immune_markers), markers = immune_markers))

FeaturePlot(pbmc, immune_markers, pt.size = .25)
```

Next is plotted a set of markers associated with different AML cell types. 

```{r,  fig.width = 10, fig.height= 10}
aml_markers = c(Blasts_and_Immature_Ery_1 = "CD34", early_erythroids = "GATA2", Immature_Ery_2 = "GATA1", Immature_Ery_3 = "TFRC", Immature_Granulocytes = "AZU1", Not_Immature_Granulocytes = "FCGR3A", Immature_Granulocytes_2 = "CXCL8", Erythroids = "HBA1")

knitr::kable(data_frame(populations = names(aml_markers), markers = aml_markers))

FeaturePlot(pbmc, aml_markers, pt.size = .25)
```

```{r, eval = F}
known_pbmc_markers = c(Monocytes_1 = "CD14", 
          Monocytes_2 = "FCN1", 
          b_1 = "CD19", 
          b_2 = "CD79A", 
          t_1 = "CD3D", 
          t_2 = "CD8A", 
          cytotoxic_t = "NKG7", 
          dendritic = "FCER1A", 
          macrophages = "S100A8", 
          megakaryocyte = "PF4", 
          memreg_t = "CCR10", 
          naive_t = "ID3")

FeaturePlot(pbmc, known_pbmc_markers)

```

Based on these data I proposed the following classification

Cluster | Observation | Classification  
-------- | ----------  | ------------  
0 | AML - Blasts and Immature Erythroids | CD34 High, Mostly found at diagnosis  
1 |  Monocytes, Macrophage cells | CD14, FCN1, S100A8  
2 | AML - Immature Granulocytes | AZU1, Mostly found at diagnosis 
3 | CD8 cytotoxic T-Cells | CD8A, NKG7 
4 | AML - Early Erythroids | CD34 high,  Mostly found at relapse  
5 | AML - mature erythroid cells | HBA1,  Mostly found at relapse  
6 | CD4 T-Cells | CD3D and not CD8A   
7 | AML ? | IL8 (CXCL8) Mostly found at diagnosis  
8 | AML ? | IL8 (CXCL8) , Mostly found at diagnosis  
9 | Dendritic | FCER1A  
10 | Megakaryocytes | High PF4  

```{r cluster_distribution}
rename_list <- list(
     Diagnosis = 1,
     Remission = 2,
     Relapse = 3)

cluster_ids <- pbmc@ident
cell_ids <- pbmc@data.info$orig.ident
levels(cell_ids) <- rename_list

cluster_summary <- data_frame(id = cell_ids, cluster = cluster_ids)
cluster_summary <- group_by(cluster_summary, id, cluster) %>% summarize(cells = n())

ggplot(cluster_summary, aes(cluster, cells, fill = cluster)) +
  facet_wrap(~id, scales = "free_y") +
  ylab("Number of Cells") +
  scale_fill_brewer(palette = "Paired") +
  geom_bar(stat = "identity")
```



```{r cluster_rename, eval= T, fig.width = 14, fig.height = 14 }
new.cluster.ids <- c(
                     "Blasts and Immature Eryth",
                     "CD14+ Monocytes", 
                     "Immature Granulocytes",
                     "CD8 T cells", 
                     "Early Erythroids",
                     "Mature Erythroids",
                     "CD4 T cells", 
                     "AML subpopulation 1",
                     "AML subpopulation 2",
                     "Dendritic",
                     "Megakaryocytes"
                    )



current.cluster.ids <- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
pbmc@ident <- plyr::mapvalues(pbmc@ident, from = current.cluster.ids, to = new.cluster.ids)

TSNEPlot(pbmc, 
                   do.label = T, 
                   pt.size = 2, 
                   do.return = F, 
                   colors.use = brewer.pal(n = 11, "Paired"), 
                   label.size = 5)
```


```{r, fig.width = 8, fig.height= 20 }
cell_ids <- map(c(1, 2, 3), ~pbmc@cell.names[pbmc@data.info$orig.ident == .x])
.cols <- brewer.pal(n = 11, "Paired")
cols_to_pick <- list(c(1:9),
                     c(2:7, 10:11),
                     -7)
p <- map2(cell_ids, 
         cols_to_pick,
         ~TSNEPlot(pbmc, 
                   do.label = T, 
                   pt.size = 0.5, 
                   cells.use = .x, 
                   do.return = T, 
                   colors.use = .cols[.y], 
                   label.size = 5))

titles <- c("Diagnosis", "Remission", "Relapse")

p <- map2(p, titles,
            ~.x + 
            coord_cartesian(c(-40, 40), c(-40, 40)) + 
            labs(title = .y) +
            theme(legend.position = "none"))

plot_grid(plotlist = p, nrow = 3, align = "hv")
```

```{r save_objs, eval = T}
saveRDS(pbmc, "analyzed_seurat_object.rds")
```