shell.executable("/bin/bash")
shell.prefix("source ~/.bash_profile; ")
import glob

""" Snakefile for combining all 4 indices from each 10x sample. Used to
    avoid demultiplexing from bcl files as per the 10x pipeline. """

SRC = "../src"

def fastq_names(sample_file, in_directory, out_directory):
    """ the demultiplexing produces 4 fastqs per sample, 
    in order for cell ranger to recognize all 4, they need to be combined.
    This function returns a list of fastq names for the combined fastqs
    and is the main function used in the /src/combine_fqs.py script """

    fqs = glob.glob(in_directory + "/*.fastq.gz")

    sample_names = [x.strip() for x in open(sample_file)]

    outnames = []
    novaseq = False 
    for sample in sample_names:
        
        fqs_with_name = [x for x in fqs if sample in x]

        # determine the set of lanes, and pick a sample id (take first)
        fqregex = re.compile(".*_(S[0-9]+)_(L00[1-8])_[IR][12]_001[.]fastq[.]gz")
        fqregex_novaseq = re.compile(".*_(S[0-9]+)_[IR][12]_001[.]fastq[.]gz")

        lanes = set()
        sample_id = ""

        for fq in fqs_with_name:

            try:
                sid, lane = fqregex.match(fq).groups()
            except AttributeError:
                try:
                    sid = fqregex_novaseq.match(fq).groups()[0]
                    novaseq = True
                except:
                    sys.exit("Unable to extract sample, lane from fastq name") 

            if sample_id == "":
                sample_id = sid

            if not novaseq:
                lanes.add(lane)

        if novaseq:
            R1_fqs = [x for x in fqs_with_name if "_R1_" in x]
            if R1_fqs:
                outname =  sample + "_" + sample_id + "_L001" 
                outnames.append(outname)
            continue

        for lane_id in lanes:

            per_lane_fqs = [x for x in fqs_with_name if lane_id in x]

            R1_fqs = [x for x in per_lane_fqs if "_R1_" in x]
            
            if R1_fqs:
                outname =  sample + "_" + sample_id + "_" + lane
                outnames.append(outname)
    return outnames 

# determine concatenated fastq names
FQS = fastq_names(SAMPLE_SHEET, DATA + "/raw_data/", DATA)

rule make_index_fastqs:
    """ the 10x pipeline requires a seperate fastq with the index sequence
    for each sample. The index and index base qualities can added to the bam
    output, but as far as i can tell the index qualities aren't used for anything 
    in the pipeline. This script takes R1 fastqs and generates I1 fastqs, with
    dummy sequence qualities added."""
    input: 
      fq = DATA + "/raw_data/combined/{fqs}_R1_001.fastq.gz",
    output:
      fq = DATA + "/raw_data/combined/{fqs}_I1_001.fastq.gz",
    params:
      job_name = "add_idx",
      memory = "select[mem>4] rusage[mem=4]",
    threads: 2 #gzip will take up another thread
    log: DATA + "/raw_data/combined/logs/idx.out"
    shell:
      """
      {BIN}/makeIdxFastq {input.fq} \
      | gzip > {output.fq} 
      """

rule concatenate_fastqs:
    """ concatenate the 4 fastqs generated by the demultiplexing
    into a single fastq (by read). Samples are chosen based on supplied
    text file with each sample id listed per line """
    output:
      expand("{data}/raw_data/combined/{fqs}_R1_001.fastq.gz",
      data = DATA, fqs = FQS)
    params:
      indir = DATA + "/raw_data/",
      outdir = DATA + "/raw_data/combined/",
      job_name = "combine",
      memory = "select[mem>4] rusage[mem=4]",
    log: DATA + "/raw_data/logs/combine.out"
    shell:
      """
      module load python3
      python3 {SRC}/combine_fqs.py -s {SAMPLE_SHEET} \
        -f {params.indir} \
        -o {params.outdir} 
      """

